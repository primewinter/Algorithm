package programmers.level01;

public class P29 {
	/*
	 * 콜라츠 추측
	 * https://programmers.co.kr/learn/courses/30/lessons/12943
	 * 문제 설명
	1937년 Collatz란 사람에 의해 제기된 이 추측은, 주어진 수가 1이 될때까지 다음 작업을 반복하면, 모든 수를 1로 만들 수 있다는 추측입니다. 작업은 다음과 같습니다.
	
	1-1. 입력된 수가 짝수라면 2로 나눕니다. 
	1-2. 입력된 수가 홀수라면 3을 곱하고 1을 더합니다.
	2. 결과로 나온 수에 같은 작업을 1이 될 때까지 반복합니다.
	예를 들어, 입력된 수가 6이라면 6>3>10>5>16>8>4>2>1 이 되어 총 8번 만에 1이 됩니다. 위 작업을 몇 번이나 반복해야하는지 반환하는 함수, solution을 완성해 주세요. 단, 작업을 500번을 반복해도 1이 되지 않는다면 -1을 반환해 주세요.
	
	제한 사항
	입력된 수, num은 1 이상 8000000 미만인 정수입니다.
	입출력 예
	n	result
	6	8
	16	4
	626331	-1
	입출력 예 설명
	입출력 예 #1
	문제의 설명과 같습니다.
	
	입출력 예 #2
	16 -> 8 -> 4 -> 2 -> 1 이되어 총 4번만에 1이 됩니다.
	
	입출력 예 #3
	626331은 500번을 시도해도 1이 되지 못하므로 -1을 리턴해야합니다.
	 */
	public static int solution(int num) {
		int num2 = num;
	      
		System.out.println(num+" || "+num2);
		for(int answer=1; answer <= 500; answer++) {
			if(num==1) { 
				return answer-1;
			}
			num = num%2==0?num/2:num*3+1; // 실패 : int의 범위를 넘어갔을 때 2로 나누면 나머지가 0이 된다.(쓰레기값이 도출된다.) 그러므로
			num2 = num2%2==1?num2*3+1:num2/2; // 성공 : n%2==1 로 먼저 필터링을 하는 것이 좋다.
			if(answer==106) { System.out.println(num%2); }
			System.out.println(num+" || "+num2+" ("+answer+")");
		}
		
		return -1;
	}
	
	
	public static int solution2(int num) {
		int answer = 0;
		while(answer!=500) {
			if(num==1) { return answer; }
			if(num%2==0) {
				num /= 2;
				answer++;
			} else {
				num = num*3+1;
				answer++;
			}
		}
		
		return answer==500?-1:answer;
	}
	
	// 다른 사람 풀이 : long 타입으로 계산을 하면 된다!!!
	public int collatz(int num) {
	    long n = (long)num;
	    for(int i =0; i<500; i++){      
	      if(n==1) return i;
	      n = (n%2==0) ? n/2 : n*3+1;            
	    }
	    return -1;
	  }
	
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		solution(626331);

	}

}
